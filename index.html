<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Windborne Application</title>
  <link rel="preconnect" href="https://unpkg.com"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <style>
    html,body,#app{height:100%;margin:0}
    #map{height:100%}
    .panel{position:absolute;top:10px;left:10px;z-index:1000;background:#ffffffd9;padding:10px 12px;border-radius:12px;backdrop-filter:saturate(1.2) blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.15);max-width:520px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .panel h1{margin:0 0 6px 0;font-size:16px}
    .row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap}
    .btn{padding:6px 10px;border-radius:8px;border:1px solid #ccd;background:#f7f7ff;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .status{padding:2px 8px;border-radius:999px;border:1px solid #ccd;background:#f5fff5;font-size:12px}
    .status.err{background:#fff5f5;border-color:#f3c0c0}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
    .footer{position:absolute;bottom:10px;left:10px;z-index:1000;background:#ffffffd9;padding:8px 10px;border-radius:10px;font-size:12px;box-shadow:0 8px 24px rgba(0,0,0,.15);max-width:640px}

    .leaflet-div-icon{background:transparent;border:none}
    .leaflet-marker-icon{cursor:pointer}

    /* label is clickable (no pointer-events:none) */
    .wb{display:inline-flex;align-items:center;gap:8px}
    .wb-dot{
      position:relative; width:14px; height:14px; border-radius:50%;
      background:
        radial-gradient( circle at 35% 35%, #ffffffaa 0 28%, transparent 29% ),
        linear-gradient(135deg,#7dd3fc 0%, #38bdf8 40%, #2563eb 75%, #1e3a8a 100%);
      border:1px solid #0b3e9a;
      box-shadow:0 0 0 1.5px #fff, 0 8px 16px rgba(0,0,0,.18);
    }
    .wb-dot::before{content:""; position:absolute; inset:-6px; border-radius:50%;
      background:radial-gradient(circle,#fff6 0 45%, transparent 60%)}
    .wb-dot::after{
      content:""; position:absolute; left:50%; bottom:-4px; width:6px; height:6px;
      transform:translateX(-50%) rotate(45deg);
      background:#1e3a8a; border:1px solid #0b3e9a; border-radius:1px; box-shadow:0 0 0 1px #fff inset;
    }
    .wb-val{
      font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; color:#111;
      background:#fff; border:1px solid #0002; border-radius:999px;
      padding:1px 6px; line-height:16px; box-shadow:0 1px 3px rgba(0,0,0,.08);
    }
  </style>
</head>
<body>
<div id="app">
  <div class="panel">
    <h1>Windborne Application - Kedari Chowtoori</h1>
    <div class="row">
      <button id="refresh" class="btn">Refresh data</button>
      <button id="toggle" class="btn">Pause</button>
      <label class="mono">Frame: <span id="frameLabel">…</span></label>
      <span id="proxyStatus" class="status mono">checking proxy…</span>
    </div>
    <div class="row mono" style="font-size:12px">
      Data via hard-coded proxy. (https://proxy-fmd5.vercel.app/api/proxy?url=)<br/>
      Label shows <strong>third JSON value × 100 (truncated)</strong>.
    </div>
  </div>
  <div id="map"></div>
  <div class="footer">
    Tip: 00 = most recent hour. Animation loops 23 → 0. Popups persist across frames and update live.
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
/* ========= Config ========= */
const WB_BASE   = 'https://a.windbornesystems.com/treasure/';
const SNAP_MAX  = 24;    // 00..23
const PROXY     = 'https://proxy-fmd5.vercel.app/api/proxy?url='; // ?url= form
const MODEL_HPA = 150;   // fixed model level for Open-Meteo popups

/* ========= Proxy helper ========= */
function buildProxiedUrl(target){
  const p = PROXY.trim();
  if (!p) return target;
  if (p.includes('{url}')) return p.replace('{url}', encodeURIComponent(target));
  if (/[?&]url=$/.test(p) || /\?$/.test(p)) return p + encodeURIComponent(target);
  if (p.endsWith('/')) return p + encodeURIComponent(target);
  return p + encodeURIComponent(target);
}

/* ========= Map (keep popups on map clicks) ========= */
const map = L.map('map', {worldCopyJump:true, closePopupOnClick:false}).setView([20,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 7, attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

/* ========= Robust fetch/parse for Windborne ========= */
function parsePossiblyWeirdJson(text){
  try { return JSON.parse(text); } catch(_){}
  const lines = text.split(/\r?\n+/).map(s=>s.trim()).filter(Boolean);
  if(lines.length>1 && lines.every(s=>s.startsWith('{') && s.endsWith('}'))){
    try { return JSON.parse('['+lines.join(',')+']'); } catch(_){}
  }
  const repaired = text.replace(/,(\s*[}\]])/g,'$1');
  try { return JSON.parse(repaired); } catch(_){}
  const tripletRe = /\[\s*([-+\d\.eE]+)\s*,\s*([-+\d\.eE]+)\s*,\s*([-+\d\.eE]+)\s*\]/g;
  const out=[]; let m; while((m=tripletRe.exec(text))) out.push([+m[1],+m[2],+m[3]]);
  if(out.length) return out;
  throw new Error('Unparseable JSON');
}
async function fetchJsonViaProxy(url){
  const proxied = buildProxiedUrl(url);
  const res = await fetch(proxied, { cache:'no-store', credentials:'omit', mode:'cors' });
  if(!res.ok) throw new Error('Proxy HTTP '+res.status);
  const text = await res.text();
  return parsePossiblyWeirdJson(text);
}

/* ========= Uniform icon (value ×100, decimals removed) ========= */
function makeIcon(val){
  let txt = '?';
  const n = Number(val);
  if (Number.isFinite(n)) txt = String(Math.trunc(n * 100));
  return L.divIcon({
    className: 'wb-icon',
    html: `<div class="wb"><span class="wb-dot"></span><span class="wb-val">${txt}</span></div>`,
    iconSize: [1,1],
    iconAnchor: [7,9]
  });
}

/* ========= Open-Meteo (direct) for popup comparisons ========= */
async function getOpenMeteoSpeed(lat, lon, levelHpa, hourOffset){
  const base = 'https://api.open-meteo.com/v1/gfs';
  const common = `latitude=${lat}&longitude=${lon}&past_days=1&forecast_days=1&timeformat=unixtime`;

  const fetchOM = async (qs) => {
    const url = `${base}?${common}&${qs}`;
    const res = await fetch(url, { cache:'no-store', credentials:'omit', mode:'cors' });
    if (!res.ok) throw new Error(`Open-Meteo HTTP ${res.status}`);
    return res.json();
  };

  // try u/v — but don't die if it fails
  let j, times;
  try {
    j = await fetchOM(`hourly=u_component_of_wind_${levelHpa}hPa,v_component_of_wind_${levelHpa}hPa`);
    times = j.hourly?.time || [];
    if (times.length){
      const i = nearestIdx(times); // your existing nearest function
      const u = j.hourly?.[`u_component_of_wind_${levelHpa}hPa`]?.[i];
      const v = j.hourly?.[`v_component_of_wind_${levelHpa}hPa`]?.[i];
      if (typeof u === 'number' && typeof v === 'number') return { speed: Math.hypot(u, v), src: 'uv' };
    }
  } catch (_) {
    // fall through to speed/direction
  }

  // fallback: speed + direction
  j = await fetchOM(`hourly=wind_speed_${levelHpa}hPa,wind_direction_${levelHpa}hPa`);
  times = j.hourly?.time || [];
  if (times.length){
    const i = nearestIdx(times);
    const ws = j.hourly?.[`wind_speed_${levelHpa}hPa`]?.[i];
    if (typeof ws === 'number') return { speed: ws, src: 'ws' };
  }
  throw new Error('Open-Meteo data unavailable');
}

/* ========= Data & prebuilt layers ========= */
let hourly = [];                                  // [24][N] of [lat,lon,val]
const hourLayers = new Array(SNAP_MAX).fill(null); // LayerGroup per hour
const frameOrder = Array.from({length:SNAP_MAX}, (_,i)=>SNAP_MAX-1-i); // 23..0

async function buildHourlyLayers(){
  const snaps = await Promise.all(
    Array.from({length:SNAP_MAX}, (_,i)=>{
      const url = WB_BASE + String(i).padStart(2,'0') + '.json';
      return fetchJsonViaProxy(url).catch(()=>[]);
    })
  );
  hourly = snaps.map(arr => Array.isArray(arr) ? arr.filter(t=>Array.isArray(t) && t.length>=2) : []);

  for(let h=0; h<SNAP_MAX; h++){
    if(hourLayers[h]) { hourLayers[h].remove(); hourLayers[h] = null; }
    const layer = L.layerGroup();
    const pts = hourly[h] || [];
    for(const p of pts){
      const [lat, lon, val] = p;
      const marker = L.marker([lat, lon], { icon: makeIcon(val) });
      // Click opens the persistent popup anchored at this point
      marker.on('click', () => openPersistentPopup(lat, lon, h));
      layer.addLayer(marker);
    }
    hourLayers[h] = layer;
  }
}

/* ========= Persistent popup that survives frame changes ========= */
const persistentPopup = L.popup({ autoClose:false, closeOnClick:false, closeButton:true });
let selected = null; // {lat, lon} anchor (we'll snap to nearest per-frame)

function nearestPoint(points, lat, lon){
  if(!points || !points.length) return null;
  let best=null, bestD=Infinity;
  for(const p of points){
    const d = (p[0]-lat)*(p[0]-lat) + (p[1]-lon)*(p[1]-lon);
    if(d < bestD){ bestD = d; best = p; }
  }
  return best; // [lat, lon, val]
}

function updatePersistentPopupForHour(hour){
  if(!selected) return;
  const pts = hourly[hour] || [];
  const np = nearestPoint(pts, selected.lat, selected.lon);
  if(!np){
    // keep position but tell user no point in this frame
    persistentPopup.setContent('<i>No nearby balloon at this frame.</i>');
    return;
  }
  const [plat, plon, pval] = np;
  selected.lat = plat; selected.lon = plon; // snap to current nearest
  const valTxt = Number.isFinite(+pval) ? (+pval).toFixed(2) : '?';

  const div = document.createElement('div');
  div.innerHTML =
    `<b>Balloon @ ${plat.toFixed(3)}, ${plon.toFixed(3)}</b><br/>` +
    `Third JSON value: <b>${valTxt}</b><br/>` +
    `<em>Loading model @ ${MODEL_HPA} hPa…</em>`;

  persistentPopup.setLatLng([plat, plon]).setContent(div);
  persistentPopup.openOn(map);

  getOpenMeteoSpeed(plat, plon, MODEL_HPA, hour)
    .then(({speed})=>{
      const delta = Number.isFinite(+pval) ? (speed - (+pval)) : null;
      div.innerHTML =
        `<b>Balloon @ ${plat.toFixed(3)}, ${plon.toFixed(3)}</b><br/>` +
        `Third JSON value: <b>${valTxt}</b><br/>` +
        `Model speed @ ${MODEL_HPA} hPa: <b>${speed.toFixed(2)}</b><br/>` +
        `Δ (model − value3): <b>${delta!=null ? delta.toFixed(2) : 'n/a'}</b>`;
    })
    .catch(()=>{
      div.innerHTML =
        `<b>Balloon @ ${plat.toFixed(3)}, ${plon.toFixed(3)}</b><br/>` +
        `Third JSON value: <b>${valTxt}</b><br/>` +
        `<span style="color:#a00">Model fetch failed.</span>`;
    });
}

function openPersistentPopup(lat, lon, hour){
  selected = { lat, lon };
  updatePersistentPopupForHour(hour);
}
map.on('popupclose', (e)=>{ if(e.popup === persistentPopup) selected = null; });

/* ========= Animation (layer swapping) ========= */
const frameLabel = document.getElementById('frameLabel');
const proxyStatus = document.getElementById('proxyStatus');
let currLayer = null;
let frameIdx = -1;
let playing = true;
let rafId = null;
let lastTick = 0;
const FRAME_MS = 900; // playback speed

function setProxyStatus(ok, msg){
  proxyStatus.textContent = msg;
  proxyStatus.className = 'status mono' + (ok? '' : ' err');
}

function showFrame(idx){
  const hour = frameOrder[idx];
  if(currLayer) currLayer.remove();
  currLayer = hourLayers[hour];
  if(currLayer) currLayer.addTo(map);
  frameLabel.textContent = String(hour).padStart(2,'0') + ' (00=now)';

  // keep popup open & refreshed across frames
  if (selected && persistentPopup && !persistentPopup._closed) {
    updatePersistentPopupForHour(hour);
  }
}

function tick(ts){
  if(!playing){ rafId = requestAnimationFrame(tick); return; }
  if(!lastTick) lastTick = ts;
  const elapsed = ts - lastTick;
  if(elapsed >= FRAME_MS){
    lastTick = ts;
    frameIdx = (frameIdx + 1) % frameOrder.length;
    showFrame(frameIdx);
  }
  rafId = requestAnimationFrame(tick);
}
function startAnim(){ if(!rafId) rafId = requestAnimationFrame(tick); }
function stopAnim(){ if(rafId){ cancelAnimationFrame(rafId); rafId = null; }}

/* ========= UI ========= */
document.getElementById('toggle').addEventListener('click', ()=>{
  playing = !playing;
  document.getElementById('toggle').textContent = playing ? 'Pause' : 'Play';
});

document.getElementById('refresh').addEventListener('click', async ()=>{
  stopAnim();
  frameLabel.textContent = '…';
  try{
    await fetch(buildProxiedUrl(WB_BASE+'00.json'), {method:'HEAD', mode:'cors', credentials:'omit'});
    setProxyStatus(true, 'proxy OK');
  }catch(_){
    setProxyStatus(false, 'proxy unreachable');
  }
  await buildHourlyLayers();
  frameIdx = -1;
  showFrame(++frameIdx);
  startAnim();
});

/* ========= Boot ========= */
(async function init(){
  try{
    await fetch(buildProxiedUrl(WB_BASE+'00.json'), {method:'HEAD', mode:'cors', credentials:'omit'});
    setProxyStatus(true, 'proxy OK');
  }catch(_){
    setProxyStatus(false, 'proxy unreachable');
  }
  await buildHourlyLayers();
  frameIdx = -1;
  showFrame(++frameIdx);
  startAnim();
})();
</script>

<!--
Notes
- Hard-coded proxy for Windborne: https://proxy-fmd5.vercel.app/api/proxy?url=
- Uniform glossy pin icon + value pill (third JSON value ×100, truncated).
- No trajectory lines. Prebuilt 24 LayerGroups; animation swaps layers to avoid jank.
- Popups persist across frames: a single, map-level popup is used and refreshed on each frame.
- External dataset: Open-Meteo GFS is used because it’s free, global, and provides pressure-level winds
  so we can compare model wind to the balloons at similar altitudes, live, without API keys.
-->
</body>
</html>

