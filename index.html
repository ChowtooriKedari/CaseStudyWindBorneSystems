<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Windborne Live + Open‑Meteo Wind Fusion</title>
  <link rel="preconnect" href="https://unpkg.com"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <style>
    html,body,#app{height:100%;margin:0}
    #map{height:100%;}
    .panel{position:absolute;top:10px;left:10px;z-index:1000;background:#ffffffd9;padding:10px 12px;border-radius:12px;backdrop-filter:saturate(1.2) blur(6px);box-shadow:0 8px 24px rgba(0,0,0,.15);max-width:520px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .panel h1{margin:0 0 6px 0;font-size:16px}
    .panel .row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap}
    .panel label{font-size:12px;color:#333}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;background:#eef;border:1px solid #ccd;font-size:12px;margin-right:6px}
    .legend{display:flex;align-items:center;gap:6px;margin-top:8px;font-size:12px}
    .legend .swatch{width:16px;height:10px;border-radius:3px;border:1px solid #0001}
    .footer{position:absolute;bottom:10px;left:10px;z-index:1000;background:#ffffffd9;padding:8px 10px;border-radius:10px;font-size:12px;box-shadow:0 8px 24px rgba(0,0,0,.15);max-width:640px}
    .btn{padding:6px 10px;border-radius:8px;border:1px solid #ccd;background:#f7f7ff;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .note{font-size:11px;color:#555;margin-top:6px}
    .status{padding:2px 8px;border-radius:999px;border:1px solid #ccd;background:#f5fff5;font-size:12px}
    .status.err{background:#fff5f5;border-color:#f3c0c0}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
    a.small{font-size:11px}
  </style>
</head>
<body>
<div id="app">
  <div class="panel">
    <h1>Windborne Constellation × Open‑Meteo (last 24h)</h1>
    <div class="row">
      <label>Pressure level for model winds:</label>
      <select id="level">
        <option value="100">100 hPa (~16 km)</option>
        <option value="150">150 hPa (~13 km)</option>
        <option value="200">200 hPa (~12 km)</option>
      </select>
      <button id="refresh" class="btn">Refresh</button>
      <span id="proxyStatus" class="status mono" title="CORS/proxy state">checking…</span>
      <a id="proxyHelp" href="#" class="small">set proxy</a>
    </div>
    <div class="row">
      <span class="chip">Circle color = Windborne measured scalar (assumed wind speed, m/s)</span>
      <span class="chip">Arrow = Open‑Meteo GFS wind @ chosen level</span>
    </div>
    <div class="legend">
      <div class="swatch" style="background:#74add1"></div>Low (≈2 m/s)
      <div class="swatch" style="background:#fee08b"></div>Medium
      <div class="swatch" style="background:#f46d43"></div>High (≈22 m/s)
    </div>
    <div class="note">Open‑Meteo gives no‑key global winds with pressure‑level u/v components for quick model vs balloon comparisons.</div>
  </div>
  <div id="map"></div>
  <div class="footer">
    <b>Tips</b>: Click a balloon for measured vs model wind and 24h drift track. Use the dropdown to change model level. A proxy is only needed if your browser blocks <code>a.windbornesystems.com</code> by CORS.
    <div class="note">Proxy URL forms supported: <span class="mono">https://worker.example.com/?url=</span>, <span class="mono">https://proxy.example.com/</span> (will append encoded URL), or any string containing <span class="mono">{url}</span> as a placeholder.</div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script>
// --- Config ---
const WB_BASE = 'https://a.windbornesystems.com/treasure/';
const SNAP_MAX = 24; // 00..23
const QS = new URLSearchParams(location.search);
const DEFAULT_PROXY = 'https://proxy-fmd5.vercel.app/api/proxy?url=';
// If ?proxy= is present, use that value (even empty to force direct).
// Otherwise, default to our Vercel proxy so it "just works".
const PROXY = QS.has('proxy') ? (QS.get('proxy') || '') : DEFAULT_PROXY;

// --- Proxy helpers ---
function buildProxiedUrl(target){
  if(!PROXY) return target;
  const p = PROXY.trim();
  if(p.includes('{url}')) return p.replace('{url}', encodeURIComponent(target));
  if(/[?&]url=$/.test(p) || /[?]$/.test(p)) return p + encodeURIComponent(target);
  if(p.endsWith('/')) return p + encodeURIComponent(target);
  return p + encodeURIComponent(target);
}

// --- Map setup ---
const map = L.map('map', {worldCopyJump:true}).setView([20,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 7,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const layers = {
  points: L.layerGroup().addTo(map),
  arrows: L.layerGroup().addTo(map),
  tracks: L.layerGroup().addTo(map)
};

// Simple color scale for measured speed-like value (2..22)
function colorFor(v){
  if(v==null||isNaN(v)) return '#999';
  if(v<6) return '#74add1';
  if(v<12) return '#abd9e9';
  if(v<16) return '#fee08b';
  if(v<20) return '#fdae61';
  return '#f46d43';
}

// Detect likely CORS/network error type
function isCorsLikeError(err){
  return err && (err.name === 'TypeError' || /Failed to fetch|CORS|NetworkError/i.test(String(err)));
}

// Robust JSON fetch with optional proxy fallback and strict no-credentials
async function robustFetchJson(url, opts = {}){
  const { alreadyProxied = false, noProxyFallback = false } = opts;
  try{
    const res = await fetch(url, {cache:'no-store', credentials:'omit', mode:'cors'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const text = await res.text();
    try { return JSON.parse(text); } catch(_){ /* fallthrough */ }
    const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    if(lines.length>1 && lines.every(s=>s.startsWith('{') && s.endsWith('}'))){
      try { return JSON.parse('['+lines.join(',')+']'); } catch(_){ }
    }
    const repaired = text.replace(/,(\s*[}\]])/g,'$1');
    try { return JSON.parse(repaired); } catch(_){ }
    const tripletRe = /\[\s*([-+\d\.eE]+)\s*,\s*([-+\d\.eE]+)\s*,\s*([-+\d\.eE]+)\s*\]/g;
    const out=[]; let m; while((m=tripletRe.exec(text))) out.push([+m[1],+m[2],+m[3]]);
    if(out.length) return out;
    throw new Error('Unparseable JSON');
  }catch(e){
    // If a proxy is configured and we tried a direct URL (not already proxied), retry through proxy
    if(PROXY && !alreadyProxied && !noProxyFallback && isCorsLikeError(e)){
      const proxied = buildProxiedUrl(url);
      const r = await fetch(proxied, {cache:'no-store', credentials:'omit', mode:'cors'});
      if(!r.ok) throw new Error('Proxy HTTP '+r.status);
      return r.json();
    }
    throw e;
  }
});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const text = await res.text();
    try { return JSON.parse(text); } catch(_){ /* fallthrough */ }
    const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    if(lines.length>1 && lines.every(s=>s.startsWith('{') && s.endsWith('}'))){
      try { return JSON.parse('['+lines.join(',')+']'); } catch(_){ }
    }
    const repaired = text.replace(/,(\s*[}\]])/g,'$1');
    try { return JSON.parse(repaired); } catch(_){ }
    const tripletRe = /\[\s*([-+\d\.eE]+)\s*,\s*([-+\d\.eE]+)\s*,\s*([-+\d\.eE]+)\s*\]/g;
    const out=[]; let m; while((m=tripletRe.exec(text))) out.push([+m[1],+m[2],+m[3]]);
    if(out.length) return out;
    throw new Error('Unparseable JSON');
  }catch(e){
    if(PROXY && isCorsLikeError(e)){
      const proxied = buildProxiedUrl(url);
      const res = await fetch(proxied, {cache:'no-store', credentials:'omit', mode:'cors'});
      if(!res.ok) throw new Error('Proxy HTTP '+res.status);
      return res.json();
    }
    throw e;
  }
}

async function fetchSnapshot(h){
  const hh = String(h).padStart(2,'0');
  const direct = WB_BASE + hh + '.json';
  if(PROXY){
    // Prefer proxy first when configured to avoid CORS errors
    return robustFetchJson(buildProxiedUrl(direct), { alreadyProxied: true });
  }
  return robustFetchJson(direct);
}

function haversine(a,b){
  const R=6371e3; // meters
  const toRad = d=>d*Math.PI/180;
  const dLat=toRad(b[0]-a[0]);
  const dLon=toRad(b[1]-a[1]);
  const s1=Math.sin(dLat/2), s2=Math.sin(dLon/2);
  const aa=s1*s1 + Math.cos(toRad(a[0]))*Math.cos(toRad(b[0]))*s2*s2;
  return 2*R*Math.asin(Math.sqrt(aa));
}

// Link points across hours into tracks by nearest-neighbour (greedy)
function buildTracks(hourlyPoints, maxJump=800e3){ // 800 km
  const tracks=[];
  for(let h=hourlyPoints.length-1; h>=0; h--){
    const pts = hourlyPoints[h] || [];
    const assigned = new Array(pts.length).fill(false);
    for(const tr of tracks){
      let bestIdx=-1, bestD=Infinity;
      for(let i=0;i<pts.length;i++) if(!assigned[i]){
        const d = haversine(tr.last, [pts[i][0], pts[i][1]]);
        if(d<bestD){ bestD=d; bestIdx=i; }
      }
      if(bestIdx>=0 && bestD<=maxJump){
        const p=pts[bestIdx]; assigned[bestIdx]=true; tr.pts.push({lat:p[0],lon:p[1],val:p[2],h}); tr.last=[p[0],p[1]];
      }
    }
    for(let i=0;i<pts.length;i++) if(!assigned[i]){
      const p=pts[i];
      tracks.push({pts:[{lat:p[0],lon:p[1],val:p[2],h}], last:[p[0],p[1]]});
    }
  }
  for(const tr of tracks){ tr.pts.sort((a,b)=>a.h-b.h); }
  return tracks;
}

async function getOpenMeteoWind(lat, lon, level){
  const url = `https://api.open-meteo.com/v1/gfs?latitude=${lat}&longitude=${lon}&hourly=wind_u_${level}hPa,wind_v_${level}hPa&past_days=1&forecast_days=1&timeformat=unixtime`;
  const res = await fetch(url, {cache:'no-store', credentials:'omit'});
  if(!res.ok) throw new Error('Open‑Meteo error');
  return res.json();
}

function arrow(lat, lon, u, v){
  const speed = Math.hypot(u, v);
  const dir = Math.atan2(u, v);
  const len = Math.min(1.5 + speed*0.05, 3.5);
  const dx = Math.sin(dir)*len; const dy = Math.cos(dir)*len;
  return L.polyline([[lat, lon],[lat+dy*0.01, lon+dx*0.01]], {color:'#333', weight:2, opacity:0.8, pane:'overlayPane'});
}

async function refresh(){
  const level = document.getElementById('level').value;
  const btn = document.getElementById('refresh');
  btn.disabled = true;
  layers.points.clearLayers(); layers.tracks.clearLayers(); layers.arrows.clearLayers();

  try{
    const snaps = await Promise.all(Array.from({length:SNAP_MAX}, (_,i)=>
      fetchSnapshot(i).catch(()=>[])
    ));
    const hourly = snaps.map(arr => Array.isArray(arr)? arr.filter(t=>Array.isArray(t) && t.length>=2): []);
    const tracks = buildTracks(hourly);

    for(const tr of tracks){
      if(tr.pts.length<2) continue;
      const coords = tr.pts.map(p=>[p.lat, p.lon]);
      L.polyline(coords, {color:'#888', weight:2, opacity:0.6}).addTo(layers.tracks);
    }

    const latest = hourly[0] || [];
    for(const p of latest){
      const [lat, lon, val] = p;
      const circle = L.circleMarker([lat,lon], {
        radius: 5 + (isFinite(val)? Math.min(Math.max(val,2),22)-2: 0)/2,
        color: '#000', weight: 1, fillColor: colorFor(val), fillOpacity: 0.9
      }).addTo(layers.points);

      circle.bindPopup(()=>{
        const div = L.DomUtil.create('div');
        div.innerHTML = `<b>Balloon @ ${lat.toFixed(3)}, ${lon.toFixed(3)}</b><br/>Measured scalar: <b>${val!=null? val.toFixed(2):'?'} m/s</b><br/><em>Loading Open‑Meteo…</em>`;
        getOpenMeteoWind(lat, lon, level).then(j=>{
          const u = j.hourly[`wind_u_${level}hPa`];
          const v = j.hourly[`wind_v_${level}hPa`];
          const idx = (j.hourly && j.hourly.time)? j.hourly.time.length-1 : -1;
          if(u && v && idx>=0){
            const uu = u[idx], vv = v[idx];
            const spd = Math.hypot(uu, vv);
            const err = (val!=null && isFinite(val))? (spd - val): null;
            div.innerHTML = `<b>Balloon @ ${lat.toFixed(3)}, ${lon.toFixed(3)}</b><br/>Measured: <b>${val!=null? val.toFixed(2):'?'} m/s</b><br/>Model @ ${level} hPa: <b>${spd.toFixed(2)} m/s</b><br/>Δ (model − measured): <b>${err!=null? err.toFixed(2):'n/a'} m/s</b>`;
            const arr = arrow(lat, lon, uu, vv).addTo(layers.arrows);
            circle.once('popupclose', ()=>{ layers.arrows.removeLayer(arr); });
          } else {
            div.innerHTML = `<b>Balloon @ ${lat.toFixed(3)}, ${lon.toFixed(3)}</b><br/>Measured: <b>${val!=null? val.toFixed(2):'?'} m/s</b><br/><span style='color:#a00'>Model winds unavailable at ${level} hPa.</span>`;
          }
        }).catch(()=>{
          div.innerHTML = `<b>Balloon @ ${lat.toFixed(3)}, ${lon.toFixed(3)}</b><br/>Measured: <b>${val!=null? val.toFixed(2):'?'} m/s</b><br/><span style='color:#a00'>Open‑Meteo fetch failed.</span>`;
        });
        return div;
      });
    }
  }finally{
    btn.disabled = false;
  }
}

// UI hooks
const proxyStatus = document.getElementById('proxyStatus');
function updateProxyStatus(ok, msg){
  proxyStatus.textContent = msg;
  proxyStatus.className = 'status mono' + (ok? '' : ' err');
}

// quick probe against hour 00 to reflect CORS/proxy state
(async function probe(){
  const testUrl = WB_BASE + '00.json';
  try{
    await robustFetchJson(testUrl);
    updateProxyStatus(true, PROXY? 'using proxy' : 'direct');
  }catch(e){
    if(PROXY){
      updateProxyStatus(false, 'proxy failed');
    }else{
      updateProxyStatus(false, 'CORS blocked');
    }
  }
})();

document.getElementById('refresh').addEventListener('click', refresh);

// small helper to prompt and set ?proxy=
const proxyHelp = document.getElementById('proxyHelp');
proxyHelp.addEventListener('click', (e)=>{
  e.preventDefault();
  const cur = PROXY || '';
  const val = prompt('Enter proxy base. Examples:\n  https://your-worker.example.com/?url=\n  https://your-proxy.example.com/\n  https://your-proxy.example.com/?', cur);
  if(val==null) return;
  const url = new URL(location.href);
  if(val.trim()==='') url.searchParams.delete('proxy');
  else url.searchParams.set('proxy', val.trim());
  location.href = url.toString();
});

refresh();
</script>

<!--
Deploy notes
1) Static hosting: host this file anywhere. If CORS blocks https://a.windbornesystems.com, add a proxy via the UI link or open with ?proxy=...
2) Tiny CORS proxy (Cloudflare Worker):
   export default {
     async fetch(req) {
       const u = new URL(req.url);
       const target = u.searchParams.get('url');
       if(!target) return new Response('missing url', {status:400});
       const r = await fetch(target, {headers:{'User-Agent':'windborne-fusion/1.0'}});
       const hdr = new Headers(r.headers);
       hdr.set('access-control-allow-origin','*');
       hdr.set('cache-control','no-store');
       return new Response(r.body, {status:r.status, headers:hdr});
     }
   }
3) If you control a.windbornesystems.com, add Access-Control-Allow-Origin for your origin on 200/304/204/redirects to avoid needing a proxy.
-->
<script>
// secondary boot script for mode controls and local file loading (appended)
(function(){
  const modeStatus = document.getElementById('modeStatus');
  function setMode(m){ DATA_MODE = m; modeStatus.textContent = m; }
  const demoBtn = document.getElementById('demoBtn');
  if(demoBtn){ demoBtn.addEventListener('click', function(){ setMode('demo'); refresh(); }); }
  const filePicker = document.getElementById('filePicker');
  if(filePicker){
    filePicker.addEventListener('change', async function(e){
      LOCAL_FILES.clear();
      const files = Array.from(e.target.files || []);
      for(const f of files){
        // try to extract HH from the filename like 00.json or anything_07.json
        const name = f.name.toLowerCase();
        const dot = name.lastIndexOf('.json');
        if(dot === -1) continue;
        // scan backwards for two digits before .json
        let hh = null;
        for(let i = dot-1; i>=1; i--){
          const a = name.charAt(i-1), b = name.charAt(i);
          if(a>='0'&&a<='9' && b>='0'&&b<='9'){ hh = a+b; break; }
        }
        if(!hh) continue;
        try{
          const text = await f.text();
          let data = null;
          try{ data = JSON.parse(text); }
          catch{
            const lines = text.split(/
+/).map(s=>s.trim()).filter(Boolean);
            if(lines.length>1 && lines.every(s=>s.startsWith('{') && s.endsWith('}'))){
              data = JSON.parse('['+lines.join(',')+']');
            }
          }
          if(Array.isArray(data)) LOCAL_FILES.set(hh, data);
        }catch{}
      }
      if(LOCAL_FILES.size){ setMode('local'); refresh(); }
    });
  }
})();
</script>
</body>
</html>
